.TH "Tester" 3 "Thu Apr 26 2018" "CS 301 FinalProj" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Tester
.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBrun\fP ()"
.br
.in -1c
.SH "Member Function Documentation"
.PP 
.SS "void Tester::run ()"
The following code will read the config file
.PP
initialized varibales
.PP
opens file then make sure it was successful
.PP
loop to run once for each config
.PP
loops through string until it finds equals sets pointer to j 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 gets the part of the input after the equals sign
.PP
this block of code adds the values from the config file to the appropriate variables\&. 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 int used to store # of instructions, must be <= 100
.PP
} 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 ------------------------------------------------------------------/// ------------------------------------------------------------------/// ------------------------------------------------------------------/// ------------------------------------------------------------------/// ------------------------------------------------------------------/// 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 \fBParser\fP is run through instruction memory to initializes instructions Initializes the instruction memory with the input file\&. 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 \fBInstruction\fP i = im->getInstruction('0x04000008'); string s = i\&.getString(); cout<<s<<endl; 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 Sets first address at the start and creates Program Counter Object
.PP
Creates controlunit object\&.
.PP
build 5 Multiplexors
.PP
only ADD
.PP
ADD and \fBALU\fP Result
.PP
\fBALU\fP and \fBALU\fP Result
.PP
Loop should run until end of program, ends when the instruction memory gets to an invalid program\&. 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 If the user chose to use single step mode, this code asks the user to press y to continue, will continuously run until user enters y 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 FETCH Retrives address from the instruction memory as a string of 1s/0s\&. 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 Adds 4 to current address and stores the result\&.
.PP
sets values to false to reset control unit, then calls method to set control values with opcode\&. 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 resets values in control unit
.PP
mux 5 is set by a combination of branch and the result of \fBALU\fP
.PP
always goes to read register1
.PP
goes to read register 2 and mux1
.PP
goes to mux1
.PP
gets last15 didgets of instruction
.PP
get j type address
.PP
function code 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 Shifts the value to the left (value used for address in jtype)
.PP
test for shift left 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 must wait for result of Mux5
.PP
Sends reg2 and reg3 to mux1
.PP
write register gets value from mux1 if a writeReg occurs this stores the register to be written to 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 Converstion to bitset so a conversion to int can be done
.PP
Converts from bitset to integer
.PP
Readreg accepts decimal value as a string, so we use to string
.PP
Converts values from hex (how its stored in register) to binary
.PP
test for mux1
.PP
sign extend accepts bitset\&.
.PP
second mux decided if imm or register 2 should go to the \fBALU\fP extended in bin, val at reg2 is in hex rn 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 calls second mux to determine second input for alu
.PP
The following code acts as the \fBALU\fP control for ALU3
.PP
SLT, ADD, SUB, SLT
.PP
Add
.PP
Subtract
.PP
SLT instruction, not yet implemented in \fBALU\fP
.PP
Result gets 'equal' or 'not equal'
.PP
runs for lw and sw 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 if this runs it is a branch instruction AND the branch condition passed\&. Basically the AND in the data path\&. 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 Not needed but avoids an unused warning for mux5 if no branches
.PP
if there is a memory write (sw) it occurs here
.PP
valAtReg2 is value to be written address to be written to is alu3 result(needs to be converted to hex) 
.br

.br

.br

.br

.br

.br

.br

.br

.br

.br
 sends result of the alu to the 3rd multiplexor
.PP
runs if op uses a memory read, and sends value to the 3rd multiplexor aluresult needs to be translated to hex 
.br

.br

.br

.br

.br

.br

.br

.br
 checks to see if it is writting to a register from mux3\&.
.PP
remeber string writeRegister holds in the reg code below should write the given value to the register 
.br

.br

.br

.br

.br

.br
 so binary can be changed to int
.PP
Shifts the previously exstended address by 2 bits(needed for b and j)
.PP
Add this value to current PC value(This doesnt make sense to me\&.\&.\&.)
.PP
result that is going to program counter
.PP
Updates program counter with correct address
.PP
prints the control fields, register memory and datamemory after each instruction if printMemoryContents is set to true\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for CS 301 FinalProj from the source code\&.
